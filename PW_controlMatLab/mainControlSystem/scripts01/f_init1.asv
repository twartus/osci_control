function [ jumpCount, jumpDel, datas, LISS331, sampFreq, t    ] = f_init1()

%To be commented later -Eric
%Drivers have been added

% variables
%%
jumpCount = 0;
jumpDel = 20;
datas.n = 500;  %how many points to plot
n = datas.n; %for shorthand
datas.Accel = zeros(1, datas.n);  %accel data array
LISS331.sampFreq = 80;

%accel normalization constants
LIS331.y0g = 0;
LIS331.y1g = 2720;

LIS331.decimals = 4;   %Acceleration reounded to 4 decimal places when normalizing
                        %This is a user defined, not a device constraint
LIS331.y1g_inverted = 1/LIS331.y1g;
LIS331.y1g_inverted = round(LIS331.y1g_inverted*10^LIS331.decimals)/10^LIS331.decimals;

sampFreq = LISS331.samplFreq;
t = (0:1/samplFreq:(datas.n-1)/samplFreq);
%Target accel
%Corrections to V are made until within yTarget+-yTriggerMin
%Corrections rate is limited at yTarget +- yCorrectionMax
%%
yaccel.Target = getappdata(gui, 'accel_Field');
yAccel.Error = 0;
% dataE = zeros(1, datas.n);
yAccel.ErrorMag = 0;
yAccel.TriggerMin = 0.001; %Minimum error to trigger correction
yCorrectionMax = 1.05; %Maximum errr correction, to avoid large correction from noise
yCorrection = 0;

yToVoltConst = .001/8; %convert yCorrection to vCorrection
corrPower = 1;  %Power of correction e.g. Linear(1), Square(2), Cube(3)
%%
fg1Freq = 80;
fg1Volt = 0.100;
fg1VCorrection = 0;
fg1VMax = 1.1;
fg1VMin = 0.050;
% fgCount = 0;    %I dont think this one is in use

%%
%more arrays
jump_Threshhold = 0.10 * 3; %ten percent of 3g
prerecordCount = 0;
n_prerecord = 100; % number to finish collecting before corrections
datas.fg1Volt = zeros(1,datas.n); %fg1 Voltages %unit = Vpp
datas.Error = zeros(1,datas.n); %difference from expected Value %unit = g
datas.Error_MA = zeros(1,datas.n); %MA of error
n_Error_MA = 20; %n of Error MA
%
req_fit = 8; %Percent fit_MA required for a big jump %unit = %
n_MA_fit = 20; %number of points in moving average for fit
datas.fit = zeros(1, datas.n); %Absolute Perfect of difference from previous accel %unit = %
datas.fit_MA = zeros(1, datas.n); %unit = %
%
req_K_AV_fit = 1; %Percent required in K_AV_fit_MA
n_timeDelay = 1; %sampled delayed between voltage and accel
n_MA_K_AV = 20; %number of points in moving average for K_AV
datas.K_AV = zeros(1, datas.n); %ratio acceleration to Voltage %unit = g/Vpp
datas.K_AV_MA = zeros(1, datas.n); %moving average %unit = g/Vpp
datas.K_AV_fit = zeros(1, datas.n); %how well each point fit to its MA %unit = %
%This is the value that decides if the K_AV_MA is suitable
datas.K_AV_fit_MA = zeros(1, datas.n); %MA of fit to MA %unit = %
              
%jumpdown
jumpDownFitTHold = 10;
jumpDownVoltTHold = 0.650;
jumpDownSafeVolt = 0.600;
noLid_K_AV = 6.7;


return;
end
